// Code generated by counterfeiter. DO NOT EDIT.
package syncfakes

import (
	"sync"
)

type FakeGitClient struct {
	CheckoutStub        func([]string) error
	checkoutMutex       sync.RWMutex
	checkoutArgsForCall []struct {
		arg1 []string
	}
	checkoutReturns struct {
		result1 error
	}
	checkoutReturnsOnCall map[int]struct {
		result1 error
	}
	CurrentBranchStub        func() (string, error)
	currentBranchMutex       sync.RWMutex
	currentBranchArgsForCall []struct {
	}
	currentBranchReturns struct {
		result1 string
		result2 error
	}
	currentBranchReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FetchStub        func([]string) error
	fetchMutex       sync.RWMutex
	fetchArgsForCall []struct {
		arg1 []string
	}
	fetchReturns struct {
		result1 error
	}
	fetchReturnsOnCall map[int]struct {
		result1 error
	}
	HasLocalBranchStub        func([]string) bool
	hasLocalBranchMutex       sync.RWMutex
	hasLocalBranchArgsForCall []struct {
		arg1 []string
	}
	hasLocalBranchReturns struct {
		result1 bool
	}
	hasLocalBranchReturnsOnCall map[int]struct {
		result1 bool
	}
	IsAncestorStub        func([]string) (bool, error)
	isAncestorMutex       sync.RWMutex
	isAncestorArgsForCall []struct {
		arg1 []string
	}
	isAncestorReturns struct {
		result1 bool
		result2 error
	}
	isAncestorReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsDirtyStub        func() (bool, error)
	isDirtyMutex       sync.RWMutex
	isDirtyArgsForCall []struct {
	}
	isDirtyReturns struct {
		result1 bool
		result2 error
	}
	isDirtyReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	MergeStub        func([]string) error
	mergeMutex       sync.RWMutex
	mergeArgsForCall []struct {
		arg1 []string
	}
	mergeReturns struct {
		result1 error
	}
	mergeReturnsOnCall map[int]struct {
		result1 error
	}
	ResetStub        func([]string) error
	resetMutex       sync.RWMutex
	resetArgsForCall []struct {
		arg1 []string
	}
	resetReturns struct {
		result1 error
	}
	resetReturnsOnCall map[int]struct {
		result1 error
	}
	StashStub        func([]string) error
	stashMutex       sync.RWMutex
	stashArgsForCall []struct {
		arg1 []string
	}
	stashReturns struct {
		result1 error
	}
	stashReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGitClient) Checkout(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.checkoutMutex.Lock()
	ret, specificReturn := fake.checkoutReturnsOnCall[len(fake.checkoutArgsForCall)]
	fake.checkoutArgsForCall = append(fake.checkoutArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.CheckoutStub
	fakeReturns := fake.checkoutReturns
	fake.recordInvocation("Checkout", []interface{}{arg1Copy})
	fake.checkoutMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitClient) CheckoutCallCount() int {
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	return len(fake.checkoutArgsForCall)
}

func (fake *FakeGitClient) CheckoutCalls(stub func([]string) error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = stub
}

func (fake *FakeGitClient) CheckoutArgsForCall(i int) []string {
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	argsForCall := fake.checkoutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitClient) CheckoutReturns(result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	fake.checkoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) CheckoutReturnsOnCall(i int, result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	if fake.checkoutReturnsOnCall == nil {
		fake.checkoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) CurrentBranch() (string, error) {
	fake.currentBranchMutex.Lock()
	ret, specificReturn := fake.currentBranchReturnsOnCall[len(fake.currentBranchArgsForCall)]
	fake.currentBranchArgsForCall = append(fake.currentBranchArgsForCall, struct {
	}{})
	stub := fake.CurrentBranchStub
	fakeReturns := fake.currentBranchReturns
	fake.recordInvocation("CurrentBranch", []interface{}{})
	fake.currentBranchMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitClient) CurrentBranchCallCount() int {
	fake.currentBranchMutex.RLock()
	defer fake.currentBranchMutex.RUnlock()
	return len(fake.currentBranchArgsForCall)
}

func (fake *FakeGitClient) CurrentBranchCalls(stub func() (string, error)) {
	fake.currentBranchMutex.Lock()
	defer fake.currentBranchMutex.Unlock()
	fake.CurrentBranchStub = stub
}

func (fake *FakeGitClient) CurrentBranchReturns(result1 string, result2 error) {
	fake.currentBranchMutex.Lock()
	defer fake.currentBranchMutex.Unlock()
	fake.CurrentBranchStub = nil
	fake.currentBranchReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGitClient) CurrentBranchReturnsOnCall(i int, result1 string, result2 error) {
	fake.currentBranchMutex.Lock()
	defer fake.currentBranchMutex.Unlock()
	fake.CurrentBranchStub = nil
	if fake.currentBranchReturnsOnCall == nil {
		fake.currentBranchReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.currentBranchReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeGitClient) Fetch(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.fetchMutex.Lock()
	ret, specificReturn := fake.fetchReturnsOnCall[len(fake.fetchArgsForCall)]
	fake.fetchArgsForCall = append(fake.fetchArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.FetchStub
	fakeReturns := fake.fetchReturns
	fake.recordInvocation("Fetch", []interface{}{arg1Copy})
	fake.fetchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitClient) FetchCallCount() int {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	return len(fake.fetchArgsForCall)
}

func (fake *FakeGitClient) FetchCalls(stub func([]string) error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = stub
}

func (fake *FakeGitClient) FetchArgsForCall(i int) []string {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	argsForCall := fake.fetchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitClient) FetchReturns(result1 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	fake.fetchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) FetchReturnsOnCall(i int, result1 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	if fake.fetchReturnsOnCall == nil {
		fake.fetchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fetchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) HasLocalBranch(arg1 []string) bool {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.hasLocalBranchMutex.Lock()
	ret, specificReturn := fake.hasLocalBranchReturnsOnCall[len(fake.hasLocalBranchArgsForCall)]
	fake.hasLocalBranchArgsForCall = append(fake.hasLocalBranchArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.HasLocalBranchStub
	fakeReturns := fake.hasLocalBranchReturns
	fake.recordInvocation("HasLocalBranch", []interface{}{arg1Copy})
	fake.hasLocalBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitClient) HasLocalBranchCallCount() int {
	fake.hasLocalBranchMutex.RLock()
	defer fake.hasLocalBranchMutex.RUnlock()
	return len(fake.hasLocalBranchArgsForCall)
}

func (fake *FakeGitClient) HasLocalBranchCalls(stub func([]string) bool) {
	fake.hasLocalBranchMutex.Lock()
	defer fake.hasLocalBranchMutex.Unlock()
	fake.HasLocalBranchStub = stub
}

func (fake *FakeGitClient) HasLocalBranchArgsForCall(i int) []string {
	fake.hasLocalBranchMutex.RLock()
	defer fake.hasLocalBranchMutex.RUnlock()
	argsForCall := fake.hasLocalBranchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitClient) HasLocalBranchReturns(result1 bool) {
	fake.hasLocalBranchMutex.Lock()
	defer fake.hasLocalBranchMutex.Unlock()
	fake.HasLocalBranchStub = nil
	fake.hasLocalBranchReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGitClient) HasLocalBranchReturnsOnCall(i int, result1 bool) {
	fake.hasLocalBranchMutex.Lock()
	defer fake.hasLocalBranchMutex.Unlock()
	fake.HasLocalBranchStub = nil
	if fake.hasLocalBranchReturnsOnCall == nil {
		fake.hasLocalBranchReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasLocalBranchReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGitClient) IsAncestor(arg1 []string) (bool, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.isAncestorMutex.Lock()
	ret, specificReturn := fake.isAncestorReturnsOnCall[len(fake.isAncestorArgsForCall)]
	fake.isAncestorArgsForCall = append(fake.isAncestorArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.IsAncestorStub
	fakeReturns := fake.isAncestorReturns
	fake.recordInvocation("IsAncestor", []interface{}{arg1Copy})
	fake.isAncestorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitClient) IsAncestorCallCount() int {
	fake.isAncestorMutex.RLock()
	defer fake.isAncestorMutex.RUnlock()
	return len(fake.isAncestorArgsForCall)
}

func (fake *FakeGitClient) IsAncestorCalls(stub func([]string) (bool, error)) {
	fake.isAncestorMutex.Lock()
	defer fake.isAncestorMutex.Unlock()
	fake.IsAncestorStub = stub
}

func (fake *FakeGitClient) IsAncestorArgsForCall(i int) []string {
	fake.isAncestorMutex.RLock()
	defer fake.isAncestorMutex.RUnlock()
	argsForCall := fake.isAncestorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitClient) IsAncestorReturns(result1 bool, result2 error) {
	fake.isAncestorMutex.Lock()
	defer fake.isAncestorMutex.Unlock()
	fake.IsAncestorStub = nil
	fake.isAncestorReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitClient) IsAncestorReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isAncestorMutex.Lock()
	defer fake.isAncestorMutex.Unlock()
	fake.IsAncestorStub = nil
	if fake.isAncestorReturnsOnCall == nil {
		fake.isAncestorReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isAncestorReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitClient) IsDirty() (bool, error) {
	fake.isDirtyMutex.Lock()
	ret, specificReturn := fake.isDirtyReturnsOnCall[len(fake.isDirtyArgsForCall)]
	fake.isDirtyArgsForCall = append(fake.isDirtyArgsForCall, struct {
	}{})
	stub := fake.IsDirtyStub
	fakeReturns := fake.isDirtyReturns
	fake.recordInvocation("IsDirty", []interface{}{})
	fake.isDirtyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitClient) IsDirtyCallCount() int {
	fake.isDirtyMutex.RLock()
	defer fake.isDirtyMutex.RUnlock()
	return len(fake.isDirtyArgsForCall)
}

func (fake *FakeGitClient) IsDirtyCalls(stub func() (bool, error)) {
	fake.isDirtyMutex.Lock()
	defer fake.isDirtyMutex.Unlock()
	fake.IsDirtyStub = stub
}

func (fake *FakeGitClient) IsDirtyReturns(result1 bool, result2 error) {
	fake.isDirtyMutex.Lock()
	defer fake.isDirtyMutex.Unlock()
	fake.IsDirtyStub = nil
	fake.isDirtyReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitClient) IsDirtyReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isDirtyMutex.Lock()
	defer fake.isDirtyMutex.Unlock()
	fake.IsDirtyStub = nil
	if fake.isDirtyReturnsOnCall == nil {
		fake.isDirtyReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isDirtyReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGitClient) Merge(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.mergeMutex.Lock()
	ret, specificReturn := fake.mergeReturnsOnCall[len(fake.mergeArgsForCall)]
	fake.mergeArgsForCall = append(fake.mergeArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.MergeStub
	fakeReturns := fake.mergeReturns
	fake.recordInvocation("Merge", []interface{}{arg1Copy})
	fake.mergeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitClient) MergeCallCount() int {
	fake.mergeMutex.RLock()
	defer fake.mergeMutex.RUnlock()
	return len(fake.mergeArgsForCall)
}

func (fake *FakeGitClient) MergeCalls(stub func([]string) error) {
	fake.mergeMutex.Lock()
	defer fake.mergeMutex.Unlock()
	fake.MergeStub = stub
}

func (fake *FakeGitClient) MergeArgsForCall(i int) []string {
	fake.mergeMutex.RLock()
	defer fake.mergeMutex.RUnlock()
	argsForCall := fake.mergeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitClient) MergeReturns(result1 error) {
	fake.mergeMutex.Lock()
	defer fake.mergeMutex.Unlock()
	fake.MergeStub = nil
	fake.mergeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) MergeReturnsOnCall(i int, result1 error) {
	fake.mergeMutex.Lock()
	defer fake.mergeMutex.Unlock()
	fake.MergeStub = nil
	if fake.mergeReturnsOnCall == nil {
		fake.mergeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mergeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) Reset(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.resetMutex.Lock()
	ret, specificReturn := fake.resetReturnsOnCall[len(fake.resetArgsForCall)]
	fake.resetArgsForCall = append(fake.resetArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.ResetStub
	fakeReturns := fake.resetReturns
	fake.recordInvocation("Reset", []interface{}{arg1Copy})
	fake.resetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitClient) ResetCallCount() int {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	return len(fake.resetArgsForCall)
}

func (fake *FakeGitClient) ResetCalls(stub func([]string) error) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = stub
}

func (fake *FakeGitClient) ResetArgsForCall(i int) []string {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	argsForCall := fake.resetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitClient) ResetReturns(result1 error) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = nil
	fake.resetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) ResetReturnsOnCall(i int, result1 error) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = nil
	if fake.resetReturnsOnCall == nil {
		fake.resetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) Stash(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.stashMutex.Lock()
	ret, specificReturn := fake.stashReturnsOnCall[len(fake.stashArgsForCall)]
	fake.stashArgsForCall = append(fake.stashArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.StashStub
	fakeReturns := fake.stashReturns
	fake.recordInvocation("Stash", []interface{}{arg1Copy})
	fake.stashMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitClient) StashCallCount() int {
	fake.stashMutex.RLock()
	defer fake.stashMutex.RUnlock()
	return len(fake.stashArgsForCall)
}

func (fake *FakeGitClient) StashCalls(stub func([]string) error) {
	fake.stashMutex.Lock()
	defer fake.stashMutex.Unlock()
	fake.StashStub = stub
}

func (fake *FakeGitClient) StashArgsForCall(i int) []string {
	fake.stashMutex.RLock()
	defer fake.stashMutex.RUnlock()
	argsForCall := fake.stashArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitClient) StashReturns(result1 error) {
	fake.stashMutex.Lock()
	defer fake.stashMutex.Unlock()
	fake.StashStub = nil
	fake.stashReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) StashReturnsOnCall(i int, result1 error) {
	fake.stashMutex.Lock()
	defer fake.stashMutex.Unlock()
	fake.StashStub = nil
	if fake.stashReturnsOnCall == nil {
		fake.stashReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stashReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	fake.currentBranchMutex.RLock()
	defer fake.currentBranchMutex.RUnlock()
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	fake.hasLocalBranchMutex.RLock()
	defer fake.hasLocalBranchMutex.RUnlock()
	fake.isAncestorMutex.RLock()
	defer fake.isAncestorMutex.RUnlock()
	fake.isDirtyMutex.RLock()
	defer fake.isDirtyMutex.RUnlock()
	fake.mergeMutex.RLock()
	defer fake.mergeMutex.RUnlock()
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	fake.stashMutex.RLock()
	defer fake.stashMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGitClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
